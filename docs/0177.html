<html>
<head>
<title>Discovering the Shadow DOM - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>发现影子DOM - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/discovering-the-shadow-dom-e541d74aefb3/#0001-01-01">https://blog.logrocket.com/discovering-the-shadow-dom-e541d74aefb3/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/5a7f4a5881a6edb85a7dd4789229cc2e.png" data-height="866" data-width="958" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*ct_7DotEJPOAOavhtBtqpA.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ct_7DotEJPOAOavhtBtqpA.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/5a7f4a5881a6edb85a7dd4789229cc2e.png" data-height="866" data-width="958" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ct_7DotEJPOAOavhtBtqpA.jpeg"/></noscript></figure>
<p>我们都很清楚<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener noreferrer">文档对象模型</a> (DOM)。多亏了它，我们可以通过JavaScript以一种有效的方式操纵HTML页面的结构和内容。</p>
<p>当然，DOM并非没有缺陷。例如，其中之一是缺乏封装，即保护文档结构的一部分免受全局处理的可能性，如CSS规则应用和JavaScript操作。</p>
<p>在本文中，我们将分析这个问题的一个例子，传统上如何解决这个问题，以及我们如何通过使用<a href="https://www.w3.org/TR/shadow-dom/" target="_blank" rel="noopener noreferrer"> Shadow DOM </a>来解决它，这是一个已经存在了一段时间的标准特性，但并不为前端开发人员所熟知。</p>
<h3>使用DOM</h3>
<p>考虑以下JavaScript代码:</p>
<figure>
<pre><code>const myGlossary = {};
​
myGlossary.renderSearchBox = function (idContainer) {
 const box = document.createElement("div");
 const form = document.createElement("form");
 const label = document.createElement("label");
 const textbox = document.createElement("input");
 const button = document.createElement("input");
 const definition = document.createElement("div");
​
 label.htmlFor = "txtTerm";
 label.innerHTML = "&lt;h4&gt;My Glossary&lt;/h4&gt;";
 form.appendChild(label);
​
 textbox.type = "text";
 textbox.id = "txtTerm";
 form.appendChild(textbox);
​
 button.type = "submit";
 button.value = " Search ";
 form.appendChild(button);
 form.appendChild(document.createElement("br"));
​
 box.style.textAlign = "center";
 box.style.fontFamily = "Verdana";
 box.appendChild(form);
​
 definition.style.padding = "15px";
 box.appendChild(definition);
​
 document.getElementById(idContainer).appendChild(box);
​
 form.onsubmit = () =&gt; {
   const term = textbox.value.trim().toLocaleLowerCase();
   const definitions = {"html": "HTML is the Web markup language.", "css": "CSS is the language describing the style of HTML documents."};
​
   if (term) {
     definition.innerHTML = definitions[term] || `'${term}' not found.`;
  }
   return false;
};
}
</code></pre>
</figure>
<p>这里，我们用一个方法定义一个对象，<em> renderSearchBox() </em>。该方法将HTML元素的标识符作为其参数，并将构建搜索文本框所需的元素附加到该元素中，如下所示:</p>
<figure><img decoding="async" src="../Images/4ca77fa7df34f8cc285066feda612a2b.png" data-height="195" data-width="457" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*z51BvlckXakaHUP8?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*z51BvlckXakaHUP8"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/4ca77fa7df34f8cc285066feda612a2b.png" data-height="195" data-width="457" data-original-src="https://storage.googleapis.com/blog-images-backup/0*z51BvlckXakaHUP8"/></noscript></figure>
<p>该搜索文本框旨在允许用户从在线服务中查找术语定义。为了简单起见，我们在代码中嵌入了术语定义。</p>
<p>当用户在文本框中插入一个词并点击搜索按钮时，就会执行<em> form.onsubmit() </em>事件监听器。这个函数仅仅显示与插入的术语相关的定义，如果有的话，否则它显示一个适当的消息。</p>
<p>下图显示了用户将<em> HTML </em>术语提交到搜索文本框时将会看到的内容:</p>
<figure><img decoding="async" src="../Images/4c40fef4945a7007ac52325297b6d189.png" data-height="219" data-width="496" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*tt3ZTMmUffZH8YFO?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*tt3ZTMmUffZH8YFO"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/4c40fef4945a7007ac52325297b6d189.png" data-height="219" data-width="496" data-original-src="https://storage.googleapis.com/blog-images-backup/0*tt3ZTMmUffZH8YFO"/></noscript></figure>
<p>您可以在HTML页面中使用myGlossary对象:</p>
<figure>
<pre><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
 &lt;title&gt;Discovering the Shadow DOM&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 &lt;div id="divBox"&gt;&lt;/div&gt;
 &lt;script type="text/javascript" src="myGlossaryBox.js"&gt;&lt;/script&gt;
 &lt;script type="text/javascript"&gt;
 myGlossary.renderSearchBox("divBox");
 &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</figure>
<p>如您所见，我们从<em> myGlossary.js </em>文件导入了脚本，并通过传递<em> divBox </em>字符串作为页面中唯一的<em> div </em>元素的标识符，调用了<em> renderSearchBox() </em>方法。</p>
<p>你可以在<a href="https://codepen.io/andychiare/pen/gQpgRN" target="_blank" rel="noopener noreferrer"> CodePen </a>上试试这个代码。</p>
<h3>DOM的问题是</h3>
<p>由上面显示的脚本创建的搜索框按预期工作。它也足够独立，可以在其他项目中重用。</p>
<p>但是，如果您在带有标记的页面中使用搜索框，会发生什么呢？</p>
<figure>
<pre><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
 &lt;title&gt;Discovering the Shadow DOM&lt;/title&gt;
 &lt;style&gt;
   h4 {
     text-align: center;
     color: red;
  }
 &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div&gt;
       &lt;h4&gt;Welcome to my great page!&lt;/h4&gt;
   &lt;/div&gt;
   &lt;!-- other markup --&gt;
 &lt;div id="divBox"&gt;&lt;/div&gt;
   &lt;!-- other markup --&gt;
 &lt;script type="text/javascript" src="myGlossaryBox.js"&gt;&lt;/script&gt;
 &lt;script type="text/javascript"&gt;
 myGlossary.renderSearchBox("divBox");
 &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</figure>
<p>在这个页面中，您会注意到一个CSS规则重新定义了<em> h4 </em>元素的颜色。当然，页面设计者打算定制欢迎消息。但是，此规则也会影响导入的搜索框的标题:</p>
<figure><img decoding="async" src="../Images/fa39a5c132cdddb2d39f6e84c4623a4d.png" data-height="223" data-width="427" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*jBl7ZOGbjRWG1FEY?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*jBl7ZOGbjRWG1FEY"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/fa39a5c132cdddb2d39f6e84c4623a4d.png" data-height="223" data-width="427" data-original-src="https://storage.googleapis.com/blog-images-backup/0*jBl7ZOGbjRWG1FEY"/></noscript></figure>
<p>由于DOM是一个全局实体，上面显示的CSS规则影响页面中的任何<em> h4 </em>元素，甚至是从外部脚本动态添加的元素。你无法保护在构建搜索框时定义的特定的<em> h4 </em>元素。如果你仅仅依赖于DOM，你不能封装它。</p>
<p>但是这个问题不仅仅与CSS规则的应用有关。想象一下，如果在页面的某个地方有以下JavaScript语句会发生什么:</p>
<figure>
<pre><code>document.getElementById("txtTerm").style.visibility = "hidden";</code></pre>
</figure>
<p>您的搜索文本框神奇地消失了:</p>
<figure><img decoding="async" src="../Images/734f3549839dfcffbdec7e99af59679b.png" data-height="206" data-width="397" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*URUIaci4BwoQPIHK?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*URUIaci4BwoQPIHK"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/734f3549839dfcffbdec7e99af59679b.png" data-height="206" data-width="397" data-original-src="https://storage.googleapis.com/blog-images-backup/0*URUIaci4BwoQPIHK"/></noscript></figure>
<p>在<a href="https://codepen.io/andychiare/pen/YRXNEB" target="_blank" rel="noopener noreferrer"> CodePen </a>上试试这段代码。</p>
<p>您不能阻止在页面的其他地方使用<em> txtTerm </em> id。而且，您无法控制任何外部代码会对您为搜索框创建的DOM元素做什么，不管是有意还是无意。</p>
<p>再说一次，DOM是一个全局实体:你添加到它里面的任何元素都是可以公开访问的，这意味着可能会发生冲突。</p>
<h3>使用iframe</h3>
<p>解决这个问题的最常见的解决方案是将表示组件的DOM部分嵌入到一个单独的DOM中，即嵌入到一个单独的HTML页面中。然后，通过iframe将该页面附加到主页上。这是谷歌使用的方法，允许开发者嵌入其地图和来自YouTube和Twitter的视频。</p>
<p>让我们来看看如何实现这个想法。像这样重新排列前面的代码:</p>
<figure>
<pre><code>const myGlossary = {};
​
myGlossary.renderSearchBox = function (idContainer) {
 const iframe = document.createElement("iframe");
 const box = document.createElement("div");
 const form = document.createElement("form");
 const label = document.createElement("label");
 const textbox = document.createElement("input");
 const button = document.createElement("input");
 const definition = document.createElement("div");
​
 label.htmlFor = "txtTerm";
 label.innerHTML = "&lt;h4&gt;My Glossary&lt;/h4&gt;";
 form.appendChild(label);
​
 textbox.type = "text";
 textbox.id = "txtTerm";
 form.appendChild(textbox);
​
 button.type = "submit";
 button.value = " Search ";
 form.appendChild(button);
 form.appendChild(document.createElement("br"));
​
 box.style.textAlign = "center";
 box.style.fontFamily = "Verdana";
 box.appendChild(form);
​
 definition.style.padding = "15px";
 box.appendChild(definition);
​
 iframe.style.border = 0;
 iframe.style.height = "200px";
 document.getElementById(idContainer).appendChild(iframe);
​
 iframe.contentDocument.body.appendChild(box);
​
 form.onsubmit = () =&gt; {
   const term = textbox.value.trim().toLocaleLowerCase();
   const definitions = {"html": "HTML is the Web markup language.", "css": "CSS is the language describing the style of HTML documents."};
​
   if (term) {
     definition.innerHTML = definitions[term] || `'${term}' not found.`;
  }
   return false;
};
}
</code></pre>
</figure>
<p>与前一版本相比，第一个区别是创建了iframe元素:</p>
<figure>
<pre><code>const iframe = document.createElement("iframe");</code></pre>
</figure>
<p>第二个区别是将表示搜索框的DOM部分附加到外部元素的方式。使用这种方法，您不需要直接将box元素附加到外部元素上。将iframe元素附加到外部元素，然后将box元素附加到与iframe相关联的文档主体。代码看起来会像这样:</p>
<figure>
<pre><code> iframe.style.border = 0;
 iframe.style.height = "200px";
 document.getElementById(idContainer).appendChild(iframe);
​
 iframe.contentDocument.body.appendChild(box);</code></pre>
</figure>
<p>使用这种方法，您将不再遇到以前版本的搜索框所遇到的冲突。</p>
<p>你可以在<a href="https://codepen.io/andychiare/pen/pQJRae" target="_blank" rel="noopener noreferrer"> CodePen </a>上试试这个。</p>
<h3>iframes的问题是</h3>
<p>在基于iframe的方法中，您应该已经注意到了一些关于iframe风格的赋值。下面让我们回忆一下这两个作业:</p>
<figure>
<pre><code> iframe.style.border = 0;
 iframe.style.height = "200px";</code></pre>
</figure>
<p>这些赋值定义了边框的粗细和iframe本身的高度。它们是提供搜索框与主页集成的假象的基础。</p>
<p>但是尽管第一条指令很好地完成了它的任务，第二条指令可能还不够。事实上，您可能会发现iframe的大小不适合文档的大小，因此您可能会看到类似下面的效果:</p>
<figure><img decoding="async" src="../Images/dbc3edeef79c424fa920890d660aff25.png" data-height="316" data-width="415" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*0E4mbRkKhgSWDRIK?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*0E4mbRkKhgSWDRIK"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/dbc3edeef79c424fa920890d660aff25.png" data-height="316" data-width="415" data-original-src="https://storage.googleapis.com/blog-images-backup/0*0E4mbRkKhgSWDRIK"/></noscript></figure>
<p>这是一个丑陋的效果，你应该避免它。</p>
<p>Iframes不是很敏感。此外，iframes被设计为在当前页面中嵌入另一个完整的文档。当我们想要将数据从父文档传递到子文档时，例如，为了配置子文档中的一些元素，这会导致更加复杂。</p>
<h3>进入影子王国</h3>
<p>在HTML页面的DOM中管理DOM部分封装的一个更好的解决方案是使用<em> Shadow DOM </em>。这是<a href="https://dom.spec.whatwg.org/#shadow-trees" target="_blank" rel="noopener noreferrer">一组标准API</a>，通过允许你为HTML元素创建一种私有DOM来实现DOM级别的封装。</p>
<p>让我们看看如何使用<em>影子DOM </em>来避免全局DOM和iframes的问题。重写实现搜索框的JavaScript代码，如下所示:</p>
<figure>
<pre><code>const myGlossary = {};
​
myGlossary.renderSearchBox = function (idContainer) {
 const box = document.createElement("div");
 const form = document.createElement("form");
 const label = document.createElement("label");
 const textbox = document.createElement("input");
 const button = document.createElement("input");
 const definition = document.createElement("div");
​
 label.htmlFor = "txtTerm";
 label.innerHTML = "&lt;h4&gt;My Glossary&lt;/h4&gt;";
 form.appendChild(label);
​
 textbox.type = "text";
 textbox.id = "txtTerm";
 form.appendChild(textbox);
​
 button.type = "submit";
 button.value = " Search ";
 form.appendChild(button);
 form.appendChild(document.createElement("br"));
​
 box.style.textAlign = "center";
 box.style.fontFamily = "Verdana";
 box.appendChild(form);
​
 definition.style.padding = "15px";
 box.appendChild(definition);
​
 const container = document.getElementById(idContainer)
 container.attachShadow({mode: "open"});
​
 container.shadowRoot.appendChild(box);
​
 form.onsubmit = () =&gt; {
   const term = textbox.value.trim().toLocaleLowerCase();
   const definitions = {"html": "HTML is the Web markup language.", "css": "CSS is the language describing the style of HTML documents."};
​
   if (term) {
     definition.innerHTML = definitions[term] || `'${term}' not found.`;
  }
   return false;
};
}
</code></pre>
</figure>
<p>在这种情况下，与脚本原始版本的唯一区别在于以下语句:</p>
<figure>
<pre><code>const container = document.getElementById(idContainer);
container.attachShadow({mode: "open"});
​
container.shadowRoot.appendChild(box);</code></pre>
</figure>
<p>我们没有直接将box元素附加到外部元素，而是首先通过attachShadow()为外部元素创建一个<em> Shadow DOM </em>。这个方法<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow" target="_blank" rel="noopener noreferrer">适用于几乎任何HTML元素</a>，它为元素的<em>影子DOM </em>生成根节点。</p>
<p>然后可以通过shadowRoot属性访问这个根节点。在上面的例子中，我们将代表搜索框的box元素附加到外部元素的shadowRoot上。当搜索框包含在任意HTML页面中时，这两条简单的指令可以保护我们免受冲突和不良影响。你可以在<a href="https://codepen.io/andychiare/pen/mQJRLN" target="_blank" rel="noopener noreferrer"> CodePen </a>上试试这个代码。</p>
<p>您可能会注意到，我们将一个文字对象作为参数传递给了attachShadow()方法。这个对象允许我们指定<em>阴影DOM </em>的创建模式。在我们的例子中，我们将值<em>打开</em>设置为<em>阴影DOM </em>模式。这意味着<em>影子DOM </em>将对标准的全局DOM操作(如CSS规则应用程序、节点选择等)隐藏。</p>
<p>然而，<em> Shadow DOM </em>对外界是公开的，所以它的元素可以通过JavaScript访问。换句话说，你可以从任何页面访问搜索框的<em>影子DOM </em>，如下所示:</p>
<figure>
<pre><code>const divBox = document.getElementById("divBox");
divBox.shadowRoot.querySelector("h4").innerText = "Changed from outside"</code></pre>
</figure>
<p>此代码替换与搜索文本框关联的标签文本。</p>
<p>如果您不希望这种情况发生，您可以选择设置<em>关闭</em>值:</p>
<figure>
<pre><code>container.attachShadow({mode: "closed"});</code></pre>
</figure>
<p>在这种情况下，<em>阴影DOM </em>将完全不可访问。</p>
<h3>结论</h3>
<p>Iframes在完成它们天生的工作时仍然有用:在当前页面中嵌入一个独立的外部页面。然而，我们现在已经看到了<em> Shadow DOM </em>如何取代基于iframes的典型封装方法，这有很多好处。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>